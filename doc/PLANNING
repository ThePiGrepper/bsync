Bsync - Build Synchronizer Tool -
Planning Document
Author: Erick Cafferata

Overview

Bsync is a tool for building applications that use external projects, like libraries,
which are versioned in a Git repository. What the tool does is retrieve all the required
versions of each dependency needed by the application (parent project) and repeats the process
recursively until it gets the right components for making the specific build version.

User Workflow:

The expected user, in theory, will have several projects in his work area or vault. The projects
in question might be: front-end/application projects which will mostly require other projects
like OSes, libraries or ports to work, and back-end/libraries projects which will mostly be
used by the former type.
The user will need to develop a certain project for which he will need a number of back-end
projects. Assuming all the related projects exist in the workarea as well. the user can
perform several actions ,like:

1) Begin to work in a new project:
  - To do this, the user will need to decide which versions of each dependency he will
    use for his project. Once decided, he will write his desired configuration inside the
    build.sync file of his new project. Once configured, the user can run the 'bsync check'
    command inside the project repository to testrun the configuration and check if there 
    are any issues. If there are, he can keep modifying the configuration file until it's OK.
  - With everything OK, the user can start developing his project. Although it is not needed,
    it is advisable to make a Git commmit for the modification of build.sync alone.

2) Return to an already existing project:
  - Go to the project repository, and run the 'bsync up [git_commit]' command. If the
    'git_commit' parameter is used, the command will attempt to checkout that commit from
    the parent project. If not, it will use the current HEAD. Then it will perform a check
    internally. If it fails, it will abort, and return every project to its original state.
  - After this, the current repository can be a detached HEAD or not, in either case, it's
    responsability of the user to do anything he sees fit.

3) Upgrade an older project to make it work with a new dependency:
  - To do this, the user has to run a 'git checkout [-b newbranch]' to go to the place in
    project history where he sees fit to place the new upgrade.
  - Now, in the [new] branch of the project repository, if the build.sync file doesnt exist,
    create build.sync and add the required dependencies. If it does exist, add the new
    dependency/version.
  - Run a 'bsync check' to make sure everything works just right. If it does. make a git
    commit(recommended) or keep working.

4) Upgrade an older project to make it work with an updated dependency:
  - To do this, is very similar to the previous one. go to the place in the project history
    where the user sees fit to place the new upgrade.
  - Modify build.sync and substitute the version part of the dependency with the new version.
  - Run a 'bsync check' to make sure everything works just right. If it does. make a git
    commit(recommended) or keep working.

5**)Solve a bug in a older project build which has been superseeded:
  - This depends mainly on a case by case basis. but the use of the tool itself is pretty
    much the same. First, checkout the desired place in the repository history to make the
    fix.
  - Make the fixes needed and commit. As long as the build.sync file already exists, and the
    dependency list doesn't need to be changed, the tool doesnt need to be used at all to
    coexist with the project progress.

TECHNICAL STUFF:

Projects and/or dependencies:

All Projects handled by bsync need to be inside the path designated by the environment
variable BSYNC_PATH.
A project and/or dependency does NOT need to be version controlled. If it is though, it
should be a Git repository. As long as it has a build.sync file the tool will understand how
to work.

Dependencies Configuration File <build.sync>:

Each project working under bsync needs to contain the dependencies file named 'build.sync'.
The 'build.sync' file can be located at the project's root folder or inside the 'src' folder.
In the case the 'build.sync' file is not available in either of those locations, the script
will keep working without error, and it will assume that the project does NOT have any
dependencies, and it will continue navigating the dependency graph.

Each dependency used by the project should be defined inside the build.sync file.
The entry format is the following one:

-One dependency per line.
-line comments start with '#' character.

example:
ProjectName|Version[:option1:option2..:optionN]//(Options still TBD)

where:
-ProjectName is the name of a project inside the directory(ies) contained in BSYNC_PATH.
-Version is the Id of the commit hash, it can take the form of:
  A git commit hash.
  A git tag.(recommended)
  A HEAD variable or any other kind of git commit-id.(not recommended)
-Other non-git related values available for version are:
  'local', relates to the current state of the directory. it does not refresh the dependency in any way.
  Leaving an empty space, this is equivalent to HEAD.

Feature List:
(from basic/main to advanced/crazy)

1) Update All dependencies required by an specific project build. [main functionality]
  [Implementation Details]
  -Middle level script: [bsync-down](bsync downstream)
  -It will handle all function-related option validation first.
  -Do a 2-phase process:
    a) First, [bsync-checkgraph] a checkup phase which will look around for any issues like:
      -Not existent buildtags: A dependency build tag in a build.sync document does not
      exist in that dependency's repository.
      -N-way dependency Ambiguity: N different build.sync files referred to different
      versions of the same dependency.
      -cyclical dependency: A dependency graph which ends at the starting point.
      This script will use a low-level script itself for parsing the build.sync file
      [bsync-parse].
    b) And second, an action phase[bsync-checkout], in which the actual dependency refresh
       will be executed. All the different checkout options will be handled by this script(eventually).
  -the initial build.sync file can be chosen in two different ways, by file and by version.
    a)by file: it uses the option -f <file> to select the initial build.sync file. Caching functionality
      is always disabled if this mode is used.
    b)by version: it is the default usage mode, it uses the build.sync file from the version pointed by HEAD
      in the current repository (the user needs to be inside the git repository, if not, the operation will abort).
      Caching functionality is enabled by default. Use --no-cache to disable caching.

2) Modify and update dependencies list securely. [Main functionality]
  [Implementation Details]
  -Middle level script: [bsync-up](bsync upstream)
  -It will handle all function-related option validation first.
  -There are several ways the user would like to modify the dependencies list, such as:
    a)By manual checkout of the dependencies repositories and then wishing that to be
    reflected in the build.sync file.
    b)By adding a particular dependency/version pair to the project dependencies directly by
    command line.
    c)By removing a particular dependency/version pair from the dependencies list directly by
    command line.
   The script will handle all previous case scenarios.
  -In either case, there will be options for handling new dependencies addition. If the option
  is not used, the script will abort and give a warning.
  -To maintain build.sync integrity, before saving changes, the script will run a check
  [bsync-checkgraph] to test if the new build list is a valid one. If not, it will abort and
  give a warning.

-----------

3) Cache functionality
  -To improve speed during bsync-down, a cache functionality will save certain builds as files, for easy
    access later.
  -To select the cache directory, the variable BSYNC_CACHE must be set with an existing path. bsync will save
    the cached files inside that folder. If BSYNC_CACHE is not set or is an illegal path, the default cache directory
    is '<git_repo_path>/.bsync'. If it does not exist, the .bsync folder will be created automatically.
  -If enabled, it will try to find a pre-saved build in the cache directory, using the commit-id of the parent repository.
    If the file is found, the checkgraph phase will be skipped, and the pre-saved file will be directly checkout.
    If the file is not found, checkgraph is executed and, only if the graph is successful and does NOT contain local(non-versioned)
    nodes, the build graph is saved inside cache directory, otherwise it is deleted after checkout.

4) Add Multi-vault Support
  [Implementation Details]
  -BSYNC_PATH modification: Extend BSYNC_PATH usability by using a $PATH-like format to support
   multiple paths. ie: PATH1:PATH2:PATH3:..PATHN
  -The build.sync file format should NOT change because of this. The tool will search for the
   right repository using BSYNC_PATH. It will search from first to last path in the BSYNC_PATH
   variable, so if there are two repositories with the name, the first one will be used.

5) Add Secondary Versions to build.sync

6) Forced version support
   -Use an additional parameter to overwrite a node version using CLI, instead of having to modify build.sync file.
   -If such node (either repository or version) does not exist, parameter will be ignored.

7) stand-alone bsync-check command
   -A single wrapper for bsync-checkgraph for quick build.sync file debugging.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>END>>>>>>>>>>>

Apendix A: Recommended Project File Structure

The following structure is the suggested project standard file structure.

ProjectName
|
|-doc
|
|-obj
|
|-src
| |
| |-build.sync
| |
| |-inc
| |
| |-build.ninja
| |
| |-OtherSrcFolder*
|   |
|   |-inc
|   |
|   |-YetAnotherSrcFolder**
